{"meta":{"title":"人生点滴","subtitle":"技术博客","description":"技术成长","author":"AresG","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"方法区详解","slug":"方法区详解","date":"2019-12-06T02:54:27.000Z","updated":"2019-12-06T05:37:44.229Z","comments":true,"path":"2019/12/06/方法区详解/","link":"","permalink":"http://yoursite.com/2019/12/06/%E6%96%B9%E6%B3%95%E5%8C%BA%E8%AF%A6%E8%A7%A3/","excerpt":"三思而后行，思危、思退、思变。 1. 方法区1.1 概念 方法区里面的数据对线程共享。 它存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化以及接口初始化中使用的特殊方法。 方法区在JVM启动时创建，在逻辑上是堆的一部分，但是虚拟机实现中可以不对该区域进行垃圾回收和内存压缩。 方法区可以是固定大小，也可以通过参数进行配置，内存可以是不连续的。 如果方法区的内存不能满足内存分配请求，会发生OOM。","text":"三思而后行，思危、思退、思变。 1. 方法区1.1 概念 方法区里面的数据对线程共享。 它存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化以及接口初始化中使用的特殊方法。 方法区在JVM启动时创建，在逻辑上是堆的一部分，但是虚拟机实现中可以不对该区域进行垃圾回收和内存压缩。 方法区可以是固定大小，也可以通过参数进行配置，内存可以是不连续的。 如果方法区的内存不能满足内存分配请求，会发生OOM。 1.2 JDK的区别 方法区是一个概念，JDK1.6是PermGen（永久代）的实现，是JVM内存中独立的一块区域（逻辑上堆的一部分）。 JDK1.8是Metaspace（元空间）的实现，是系统内存的一部分，但是运行时常量池中的StreingTable在堆中。 1.3 方法区内存溢出1public class Demo1_8 extends ClassLoader &#123; // 可以用来加载类的二进制字节码2 public static void main(String[] args) &#123;3 int j = 0;4 try &#123;5 Demo1_8 test = new Demo1_8();6 for (int i = 0; i &lt; 10000; i++, j++) &#123;7 // ClassWriter 作用是生成类的二进制字节码8 ClassWriter cw = new ClassWriter(0);9 // 版本号， public， 类名, 包名, 父类， 接口10 cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, \"Class\" + i, null, \"java/lang/Object\", null);11 // 返回 byte[]12 byte[] code = cw.toByteArray();13 // 执行了类的加载14 test.defineClass(\"Class\" + i, code, 0, code.length); // Class 对象15 &#125;16 &#125; finally &#123;17 System.out.println(j);18 &#125;19 &#125;20&#125; JDK1.6 演示永久代内存溢出 java.lang.OutOfMemoryError: PermGen space -XX:MaxPermSize=8m JDK1.8 演示元空间内存溢出java.lang.OutOfMemoryError: Metaspace -XX:MaxMetaspaceSize=8m 2. 运行时常量池 常量池就是一张表，虚拟机指令根据这张常量池表找到要执行的类名、方法名、参数类型、字面量等信息。 运行时常量池，常量池是.class文件中，当类被加载后，它的常量池信息就会放入运行时常量池，*并把里面的符号地址转为真实地址**。 1// Java源代码2String s1 = \"a\";3String s2 = \"b\";4String s3 = \"ab\";56// javap -v xxx.class7Code:8 stack=2, locals=1, args_size=19 0: aload_010 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V11 4: aload_012 5: ldc #2 // String a13 7: putfield #3 // Field s1:Ljava/lang/String;14 10: aload_015 11: ldc #4 // String b16 13: putfield #5 // Field s2:Ljava/lang/String;17 16: aload_018 17: ldc #6 // String ab19 19: putfield #7 // Field s3:Ljava/lang/String;20 22: return21 LineNumberTable:22 line 10: 023 line 12: 424 line 13: 1025 line 14: 16 3. StringTable3.1 面试题1public static void main(String[] args) &#123;2 String s1 = \"a\";3 String s2 = \"b\";4 String s3 = \"a\" + \"b\";5 String s4 = s1 + s2;6 String s5 = \"ab\";7 String s6 = s4.intern();8 // 问9 System.out.println(s3 == s4);10 System.out.println(s3 == s5);11 System.out.println(s3 == s6);12 String x2 = new String(\"c\") + new String(\"d\");13 String x1 = \"cd\";14 x2.intern();15 // 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢16 System.out.println(x1 == x2);17&#125; 3.2 StringTable特性 StringTable是HashTable实现。 常量池中的字符串仅是符号，第一次用到是才变为对象。（懒加载） 利用串池机制来避免字符串重复创建。 字符串变量拼接的原理是StringBuilder。 字符串常量拼接的原理是编译优化。（编译时拼接后的常量已经确定） 可以利用intern()方法主动将串池中还没有的字符串对象放入串池 1.8将这些字符串对象尝试放入串池，如果串池中存在，则不会放入，如果不存在则放入串池，并把串池中的对象返回。 1.6将这些字符串对象尝试放入串池，如果串池中存在，则不会放入，如果不存在，将此对象复制一份，放入串池，并把串池中的对象返回。 3.3 面试题分析1String s1 = \"a\"; // [\"a\"] 2String s2 = \"b\"; // [\"a\",\"b\"]3String s3 = \"a\" + \"b\"; // [\"a\",\"b\",\"ab\"]4//(new StringBuilder(\"a\")+new StringBuilder(\"b\")).toString(),toString()也是调用new String()5String s4 = s1 + s2; // 在堆中6String s5 = \"ab\"; // 常量池中已经存在，直接获取7// 1.8，将堆中\"ab\"尝试放入StringTable中，此时已经存在，不存入，返回值是StringTable中\"ab\"8String s6 = s4.intern(); // 常量池9// 问10System.out.println(s3 == s4); // s3在常量池，s4在堆中 false11System.out.println(s3 == s5); // 都在常量池 true12System.out.println(s3 == s6); // 都在常量池 true13String x2 = new String(\"c\") + new String(\"d\"); // 堆中14String x1 = \"cd\"; // 常量池中15x2.intern(); //常量池中存在，不放入，并且没有获取返回值 x2还在堆中16// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢17System.out.println(x1 == x2); // x1在常量池中，x2在堆中 false18// jdk1.6是复制一份对象，把复制的对象存入常量池","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Tomcat集群和调优","slug":"Tomcat集群和调优","date":"2019-12-04T11:43:50.000Z","updated":"2019-12-06T02:55:49.010Z","comments":true,"path":"2019/12/04/Tomcat集群和调优/","link":"","permalink":"http://yoursite.com/2019/12/04/Tomcat%E9%9B%86%E7%BE%A4%E5%92%8C%E8%B0%83%E4%BC%98/","excerpt":"1. Tomcat集群1.1 简介 由于单台Tomcat服务器的承受能力有限，当业务系统用户量较大，请求压力比较大时，单台Tomcat扛不住，这时需要搭建Tomcat集群。","text":"1. Tomcat集群1.1 简介 由于单台Tomcat服务器的承受能力有限，当业务系统用户量较大，请求压力比较大时，单台Tomcat扛不住，这时需要搭建Tomcat集群。 集群的好处： 可伸缩性。由于集群中的服务器提供相同的功能服务，所以随着业务量的增加，可以很容易横向扩展，提高集群处理能力。负载均衡会按照指定策略将请求合理的分发到各个服务器进行处理，并且对客户端是透明的。 高可用性。由于服务是由一组服务器共同提供的，当一台服务器出现异常，系统整体功能不会受到影响。 高性能。在集群环境下，负载均衡策略会将客户端请求合理的分配到各个服务器，降低了单台服务器的处理数量，提高了处理性能。 注意：虽然集群可以支持三高，但是它的引入增加了系统的复杂度，它要求应用服务器提供相关的管理、同步等功能。 常见的集群部署方式： Apache + Tomcat集群 Nginx + Tomcat集群 …… 1.2 环境配置​ 本文采用Nginx + Tomcat集群的部署方式，Nginx环境自行搭建 配置两台Tomcat，并修改端口号 分别打开两台tomcat/conf/server.xml文件，修改8005,8080，8009三个端口。 分别启动两台Tomcat应用。 修改Nginx配置文件 修改nginx.conf文件 1// 修改日志格式，显示分发到具体的服务器，测试看2 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" '3 '$status $body_bytes_sent \"$http_referer\" '4 '\"$http_user_agent\" \"$http_x_forwarded_for\"' '\"$upstream_addr\"';5 access_log logs/access.log main;6// 轮询服务器7upstream serverpool&#123;8 server localhost:8888;9 server localhost:9999;10&#125;11server &#123;12 listen 80;13 server_name localhost;14 #access_log logs/host.access.log main;15 location / &#123;16 proxy_pass http://serverpool/;17 &#125;18&#125; 启动nginx后，访问http://192.168.227.10:80/ （80端口可省略），查看nginx日志 1// 日志后面会添加到配置文件增加的'\"$upstream_addr\"'，请求到了哪个端口2\"127.0.0.1:8888\"3\"127.0.0.1:9999\" 1.3 负载均衡策略 轮询 最基本的配置方式，它是upstream模块默认的负载均衡策略。每个请求会按时间顺序逐一分配到不同的后端服务器。 配置 1upstream serverpool&#123;2 server localhost:8888;3 server localhost:9999;4&#125; 参数说明 参数 描述 fail_timeout 与max_fails结合使用 max_fails 在设置的fail_timeout时间内最大失败次数，如果这个时间内所有针对该服务器的请求都失败了，该服务器认定为停机 fail_time 服务器会被认为停机的时常，默认为10s backup 标记该服务器为备用服务器，当主服务器停止时，请求会被发送到这里 down 标记服务器永久停机 weight权重 在轮询的基础上，指定轮询几率。 配置 1upstream serverpool&#123;2 server localhost:8888 weight=3;3 server localhost:9999 weight=1;4&#125; weight参数用于指定轮询几率，weight默认值为1；weight数值与访问比率成正比，上述例子8888端口被访问几率是9999的3倍。该策略比较适合硬件差别较大的服务器。 ip_hash 指定负载均衡器按照客户端IP的分配方式，确保了相同客户端请求相同服务器，保证Session会话。 配置 1upstream serverpool&#123;2 ip_hash;3 server 192.168.1.1:8080;4 server 192.168.1.2:8080;5&#125; 1.4 Session共享方案 ip_hash轮询策略。 Session复制。 在Tomcat的conf/server.xml配置 1&lt;Cluster className=\"org.apache.catalina.ha.tcp.SimpleTcpCluster\"/&gt; 在部署的Web应用的web.xml文件中添加 1&lt;distributable/&gt; 注意：该方案适用于较小的集群环境（节点不超过4个），如果集群节点数较多，通过这种广播的形式完成Session复制，会消耗大量的网络带宽，影响服务器性能。 SSO-单点登录。 ​ 单点登录（Single Sign On），简称SSO。SSO的定义是在多个应用系统中，用户只用登录一次访问所有互相信任的应用系统，也是解决集群共享Session的方案之一。 2. Tomcat安全相关2.1 配置安全 删除webapps下的所有文件，禁用tomcat管理界面。 注释或删掉tomcat-users.xml内所有用户权限。 更改关闭Tomcat指令或禁用。 定义错误页面。 2.2 应用安全​ 大部分Web应用，都会实现自己的安全管理模块，用于控制系统的安全访问，它基本包含两个内容：认证（登录/单点登录）和授权（功能权限、数据权限）。目前相对成熟的框架： Apache Shiro SpringSecurity …… 2.3 传输安全 HTTPS介绍 HTTPS的全称是超文本传输安全协议（Hypertext Transfer Protocol Secure），是一种网络安全传输协议。在HTTP协议的基础上加入SSL/TLS来进行数据加密，保护交互数据不被泄露、窃取。 SSL和TLS是网络通信安全协议，它允许客户端和服务器之间通过安全链接通信。SSL协议有三个特征： 保密：SSL传输数据是加密的。 鉴别：通信双方的身份鉴别，通常是可选的，但至少有一端需要验证。 完整性：传输数据的完整性检查。 注意：从性能上看，加解密是非常耗时处理，尽量不要将整个Web应用采用SSL链接，实际部署中，选择有必要加密的页面进行SSL通信。 HTTPS和HTTP区别主要在以下几点： HTTPS需要到证书颁发机构CA申请SSL证书，然后与域名进行绑定，HTTP不用申请证书。 HTTP是超文本传输协议，是应用层信息传输。HTTPS则是具有SSL加密的安全传输协议，对数据的传输进行了加密，相当于HTTP的升级版。 HTTP和HTTPS是完全不同的连接方式，端口也不一样，前者是80，后者是443。 HTTP连接简单，是无状态的。HTTPS协议是由SSL+HTTP构建的可加密传输、身份认证的网络协议。 注意：HTTPS原理和证书相关可另找资料学习。 Tomcat的HTTPS 生成密钥，keytool是JDK自带工具 1keytool -genkey -alias tomcat -keypass 123456 -keyalg RSA -keystore tomcat.keystore 将密钥文件复制到tomcat/conf目录下 配置tomcat/conf/server.xml 1&lt;!-- Tomcat8.5之前 --&gt;2&lt;!-- &lt;Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\"3 maxThreads=\"150\" SSLEnabled=\"true\" scheme=\"https\" secure=\"true\"4 keystoreFile=\"conf/tomcat.keystore\" keystorePass=\"123456\"5 clientAuth=\"false\" sslProtocol=\"TLS\"/&gt; --&gt;6&lt;!-- Tomcat8.5之后 --&gt;7&lt;Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\"8 maxThreads=\"150\" SSLEnabled=\"true\" scheme=\"https\" secure=\"true\"9 clientAuth=\"false\" sslProtocol=\"TLS\"&gt;10 &lt;SSLHostConfig certificateVerification=\"false\"&gt;11 &lt;Certificate12 certificateKeystoreFile=\"conf/tomcatkey.keystore\"13 certificateKeystorePassword=\"123456\" type=\"RSA\" /&gt;14 &lt;/SSLHostConfig&gt;15&lt;/Connector&gt; 注意：注意密钥的密码。 访问：https://localhost:8443/ 3. Tomcat调优3.1 性能指标 响应时间：用户执行某个操作的耗时。大多数情况下，指的是平均响应时间。 吞吐量：给定时间内，系统支持的事务数量，计算单位TPS。 3.2 测试工具 ApacheBench ApacheJMeter WCAT WebPolygraph LoadRunner 注意：测试工具和压测后续再深入学习，至少熟练一个压测工具。 https://www.cnblogs.com/imyalost/ 3.3 调优策略​ 无监控，不调优 JVM参数配置（JVM调优主要考虑两点，内存分配和GC策略） 参数 作用 优化建议 -server 以服务端模式启动，32位JVM只有client端 开启 -Xms 初始堆内存 建议与-Xmx相同 -Xmx 最大堆内存 建议可用内存的80% -XX:MetaspaceSize 元空间初始值（JDK1.8永久代改为元空间区） -XX:MaxMetaspaceSize 元空间最大内存 默认无限 -XX:MaxNewSize 新生代最大内存 默认16M -XX:NewRatio 年轻代与老年代大小比值，取值为整数，默认2 不建议修改 -XX:SurvivorRatio Eden Tomcat配置 调整server.xml配置 修改链接器maxConnections属性，该属性决定了服务器在同一时间接收并处理的最大连接数。当达到该值后，服务器将不再处理更多的请求，额外的请求将会被阻塞直到链接数低于maxConnections，此时服务器将再次处理新链接。 tcpNoDelay属性设置为true会开启Socket的TCP_NO_DELAY选项，它会禁用delay算法，该算法用于链接小的缓冲消息，这会降低网络发送包的数量，提高网络传输效率，但是会增加响应时间。 调整maxKeepAliveRequest属性值，该属性用于控制HTTP请求的keep-alive行为，指定了链接在被服务器关闭之前可接收请求的最大数目。 修改socketBuffer属性，调整Socket缓冲区的大小。合理调整Socket缓冲器有助于提升服务器性能。 将enableLookups属性设置为false，禁用request.getRemoteHost的DNS查找功能，减少查找时间。 与Web服务器集成，将静态请求交给Web服务器处理。如Apache和Nginx。 性能优化建议 减少浏览器与服务器通信次数。 减少请求响应数据量，去除无用数据，降低网络开销。 推迟会话创建时机，对于不需要会话的尽量不要创建。无论采用何种会话管理器，会话管理都会消耗服务器性能。 不要再会话中存储大对象，导致会话占用内存过多，降低服务器性能。 尽量缩短会话有效期，能够及时移除无效会话，降低会话管理成本。 合理定义对象作用域，以便对象可以及时回收。 采用链接池提高访问性能。 对于极少变更的数据，采用缓存提高查询性能。 最小化应用日志，或者尽量采用简单的日志格式。DEBUG日志尽量详细；INFO级别日志尽量简单，仅在必要时候添加；WARN和ERROR日志做到既不影响问题定位，又要减少输出内容。","categories":[],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Tomcat总结","slug":"Tomcat总结","date":"2019-12-03T13:15:37.000Z","updated":"2019-12-06T02:55:59.575Z","comments":true,"path":"2019/12/03/Tomcat总结/","link":"","permalink":"http://yoursite.com/2019/12/03/Tomcat%E6%80%BB%E7%BB%93/","excerpt":"业精于勤荒于嬉，行成于思毁于随。 该文章通过《Tomcat架构解析》和Tomcat相关视频学习，总结的笔记，以便后续复习。 环境：JDK1.8 Tomcat 8.5.49 IDEA 2019.2","text":"业精于勤荒于嬉，行成于思毁于随。 该文章通过《Tomcat架构解析》和Tomcat相关视频学习，总结的笔记，以便后续复习。 环境：JDK1.8 Tomcat 8.5.49 IDEA 2019.2 1. Tomcat概述 Tomcat是基于Java语言的轻量级应用服务器，是完全开源免费的Servlet容器实现。 Tomcat版本对照表 规范\\版本 6.x(6.0.47) 7.x(7.0.72) 8.x(8.0.38) 8.5.x(8.5.6) 9.x(9.0.0.M11) JDK ≥5.0 ≥6.0 ≥7.0 ≥7.0 ≥8.0 Servlet 2.5 3.0 3.1 3.1 3.2 JSP 2.1 2.2 2.3 2.3 2.3 EL 2.1 2.2 3.0 3.0 3.0 WebSocket N/A 1.1 1.1 1.1 1.1 2. Tomcat目录介绍 目录 目录下文件 说明 bin / 存放Tomcat的启动、停止等批处理脚本 startup.bat,startup.sh Window和Linux的启动脚本 shutdown.bat,shutdown.sh Window和Linux的停止脚本 conf / Tomcat配置文件 Catalina 存储针对每个虚拟机的Context配置 Context.xml 定义所有Web应用均需要加载的Context配置，如果Web应用指定了自己的Context.xml，该文件会被覆盖 catalina.properties Tomcat环境变量配置 catalina.policy Tomcat运行时安全策略配置 logging.properties Tomcat日志配置文件，可以通过该文件修改Tomcat日志级别和日志路径等 server.xml Tomcat服务器的核心配置文件 tomcat-users.xml Tomcat默认用户及角色映射信息配置 web.xml Tomcat所有应用默认的部署描述文件，主要定义了基础Servlet和MIME映射 lib / Tomcat服务器所依赖的包 logs / Tomcat默认的日志存放目录 webapps / Tomcat默认的Web应用部署目录 work / Web应用JSP代码生成和编译的临时目录 3. Tomcat架构设计3.1 Tomcat整体架构​ Tomcat应用服务器如果完成Web请求需要实现两个核心功能： 处理Socket连接，负责网络字节流与Request和Response对应的转化。 加载和管理Servlet容器，处理具体的业务请求。 两者相互配合，不能单独工作。 3.2 连接器-Coyote3.2.1 架构介绍 Coyote是Tomcat的连接器，是Tomcat服务器提供给客户端访问的接口，客户端通过Coyote与服务器建立连接，发送请求并返回处理。 Coyote底层封装了Socket请求，为Catalina提供统一的接口，使Catalina与具体的网络协议和I/O方式解耦。 3.2.2 网络协议和I/O Tomcat支持的网络协议（应用层） HTTP/1.1：大部分Web应用采用的访问协议 AJP：用于和Web服务器集成（如Apache），以实现对静态资源的优化和集群部署，当前支持AJP1.3。 HTTP/2：提高了Web性能，下一代HTTP协议，自Tomcat8.5及9.0之后版本支持。 Tomcat支持的I/O（传输层） NIO：非阻塞IO，采用Java NIO库实现。 NIO2：异步I/O，采用JDK1.7最新的NIO2库实现 APR：采用Apache可移植运行库实现，是C/C++的本地库。如果采用该方案，需要单独安装APR库。 注意：8.0之后默认为NIO实现，如果采用APR，可达到Apache HTTP Server的性能。 Tomcat为了支持多种I/O和网络协议，一个容器可能对接多个连接器，类比一个房间多个门。但是单独的连接器或容器都不能对外提供服务，需要把它们组装起来才能工作，组装后的整体为Service组件。Tomcat内可以有多个Service，可以实现通过不同端口访问同一台机器上部署不同应用。 3.2.3 连接器组件 Endpoint Coyote的通信端点，即通信监听的接口，是具体的Socket接收和发送的处理器，是对传输层的抽象，实现类TCP/IP协议。 Tomcat并没有Endpoint接口，而是提供了AbstractEndpoint抽象类，它的默认实现类NioEndpoint里面定义了两个内部类Acceptor和SocketProcessor。Acceptor用于监听Socket连接请求。SocketProcessor用于处理接收到的Socket请求，它实现了Runnable接口，在run()方法里面调用协议处理组件Processor处理。为了提供性能，SocketProcessor交给线程池处理。 源码分析： 1// NioEndpoint#startInternal()2// Start poller threads3pollers = new Poller[getPollerThreadCount()];4for (int i=0; i&lt;pollers.length; i++) &#123;5 pollers[i] = new Poller();6 Thread pollerThread = new Thread(pollers[i], getName() + \"-ClientPoller-\"+i);7 pollerThread.setPriority(threadPriority);8 pollerThread.setDaemon(true);9 // 调用Poller的run()方法10 pollerThread.start();11&#125;12// 调用链13// NioEndpoint.Poller#run()-&gt;processKey()-&gt;processSocket()1415SocketProcessorBase&lt;S&gt; sc = processorCache.pop();16if (sc == null) &#123;17 sc = createSocketProcessor(socketWrapper, event);18&#125; else &#123;19 sc.reset(socketWrapper, event);20&#125;21Executor executor = getExecutor();22if (dispatch &amp;&amp; executor != null) &#123;23 // 执行SocketProcessorBase中的run()方法24 // SocketProcessorBase#run()-&gt;doRun()-&gt;NioEndpoint#doRun()25 executor.execute(sc);26&#125; else &#123;27 sc.run();28&#125;2930//整体调用链路31NioEndpoint.Poller#run()-&gt;processKey()-&gt;processSocket()32 -&gt;SocketProcessorBase#run()-&gt;doRun()-&gt;NioEndpoint#doRun() Processor Coyote的协议处理接口，Endpoint是实现TCP/IP协议，Processor是用来实现HTTP协议的，Processor接收来自Endpoint的Socket，读取字节流解析成Tomcat Request和Response对象，并通过Adapter提交给容器。Processor是对应用层的抽象。 源码分析： 1// 调用链路2NioEndpoint#doRun()-&gt;AbstractProtocol#process()-&gt;AbstractProcessorLight#process()3 -&gt;Http11Processor#service()-&gt;CoyoteAdapter#service()4 -&gt;StandardEngineValve#invoke() ProtocolHandler Coyote协议接口，通过Endpoint和Processor，实现针对具体协议的处理能力。Tomcat按照协议和I/O有6个实现类。我们在配置tomcat/conf/server.xml时，至少要指定具体的ProtocolHandler，也可以指定协议名称，如HTTP/1.1。 Adapter 由于协议不同，客户端发过来的请求协议也不同，Tomcat定义了自己的Request类来存放这些请求信息，ProtocolHandler接口负责解析请求并封装Tomcat Request类，但是这个Request不是标准的ServletRequest类，不能直接交给容器处理。Tomcat采用CoyoteAdapter适配器模式来进行相关处理。 处理过程：连接器调用CoyoteAdapter#service(Request req)方法将Tomcat Request转换为ServletRequest，再调用容器的Service方法。 3.3 容器-Catalina3.3.1 Catalina地位 ​ Tomcat本质是一款Servlet容器，因此Catalina是Tomcat核心，其他模块都是为Catalina提供支撑。比如：通过Coyote模块提供链接通信，Jasper模块提供JSP引擎，Naming提供JNDI服务，Juli提供日志服务。 3.3.2 Catalina地位结构 ​ Catalina负责管理Server，而Server表示整个服务器，Server可以有多个服务Service，每个服务Service都包含多个Connector（Coyote实现）和一个容器Container。在Tomcat启动时会初始化Catalina容器。 组件 职责 Catalina 负责解析Tomcat的配置文件，以此来创建服务器Server组件，并根据命令来对其进行管理 Server 服务器表示整个Catalina Servlet容器以及其它组件，负责组装并启动Servlet引擎，Tomcat连接器。Server通过实现LifeCycle接口，提供了一种优雅的启动和关闭整个系统方式 Service 服务是Server的内部组件，一个Server包含多个Service，它将若干个Connector绑定到一个Engine上 Connector 连接器，处理客户端通信，负责接收客户端请求，并将请求交个相关容器，最后向客户端返回响应结果 Container 容器，负责处理用户的Servlet请求，并返回对象给Web用户的模块 3.3.3 Container结构 ​ Tomcat设计了4种容器，分别是Engine、Host、Context和Wrapper。这4种容器不是平行关系，而是父子关系。 容器 描述 Engine Servlet引擎，用来管理多个虚拟站点，一个Service最多一个Engine，但是一个引擎可包含多个Host Host 虚拟主机，或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可保护多个Context Context Web程序，一个Web应用可包含多个Wrapper Wrapper Servlet，Wrapper作为容器的最底层，不包含子容器 4. Tomcat启动流程 启动时序图 主要源码调用链 1Bootstrap#main()2 // load3 -&gt;Catalina#load()-&gt;createStartDigester()(解析server.xml)4 -&gt;StandardServer#initInternal()-&gt;StandardService#initInternal()5 -&gt;StandardEngine#initInternal()-&gt;Connector#initInternal()-&gt;ProtocolHandler#init()6 -&gt;AbstractProtocol#init()-&gt;AbstractEndpoint#init()-&gt;NioEndpoint#bind()7 -&gt;serverSock.socket().bind8 // start9 -&gt;Catalina#start()-&gt;StandardServer#startInternal()10 -&gt;StandardService#startInternal()（StandardService L:416 engine.start()）11 -&gt;StandardEngine#startInternal()12 -&gt;ContainerBase#startInternal()（ContainerBase L:908 result.get()）13 -&gt;StandardHost#startInternal()-&gt;StandardContext#startInternal()14 -&gt;ContextConfig#lifecycleEvent()(处理监听事件)15 -&gt;configureStart()-&gt;webConfig()(解析web.xml)-&gt;StandardContext#loadOnStartup()16 -&gt;StandardWrapper#load()-&gt;Servlet.init()17 -&gt;StandardService#startInternal()（StandardService L:434 connector.start()）18 -&gt;Connector#startInternal()-&gt;ProtocolHandler#start()-&gt;AbstractEndpoint#start()19 -&gt;NioEndpoint#startInternal()-&gt;AbstractEndpoint#startAcceptorThreads()20 -&gt;NioEndpoint.Acceptor#run()-&gt;socket = serverSock.accept() 5. Web请求流程 请求流程，Tomcat通过Mapper组件完成请求和Wrapper的匹配。 Mapper的工作原理：Mapper组件里保存了Web应用的配置信息，其实就是容器组件和访问路径的映射关系，比如Host容器里面配置的域名、Context容器里配置的Web应用路径，以及Wrapper容器里Servlet映射的路径，可以想象这些配置信息就是多层次的Map。 当一个请求进来时，Mapper组件通过解析请求URL里面的域名和路径，再到自己保存的Map里面查找，就能定位一个Servlet。一个请求URL最后只会定位到一个Wrapper容器，也就是一个Servlet。 当用户请求链接http://www.itcast.cn/bbs/findAll之后，如何找到最终的处理Servlet。 请求时序图 Connector组件的Endpoint中的Acceptor监听客户端套接字连接并接收Socket。 将连接交给线程池Executor处理，开始执行请求响应任务。 Processor组件读取消息报文，解析请求行、请求体、请求头封装成Request对象。 Mapper组件根据请求行的URL值和请求头的Host值匹配到具体的Host容器、Context容器和Servlet容器处理请求。 CoyoteAdapter组件负责将Connector组件和Engine容器关联起来，把生成的Request对象和Response对象传递到Engine容器中，调用Pipeline。 Engine容器的管道开始处理，流程类似，最后处理Context容器的Pipeline（责任链模式）。 Context容器的管道开始处理，流程类似，最后处理Wrapper容器的Pipeline。 Wrapper容器的管道开始处理，流程类似，最后处理Wrapper容器对应的Servlet对象的处理方法。 源码调用链 1NioEndpoint.Poller#run()-&gt;processKey()-&gt;processSocket()2 -&gt;SocketProcessorBase#run()-&gt;doRun()-&gt;NioEndpoint#doRun()3 -&gt;AbstractProtocol#process()-&gt;AbstractProcessorLight#process()4 -&gt;Http11Processor#service()-&gt;CoyoteAdapter#service()5 -&gt;StandardEngineValve#invoke()-&gt;StandardHostValve#invoke()6 -&gt;StandardContextValve#invoke()-&gt;StandardWrapperValve#invoke()7 -&gt;StandardWrapper#allocate()（初始化Servlet）-&gt;Servlet#init()8 -&gt;ApplicationFilterFactory#createFilterChain()9 -&gt;ApplicationFilterChain#doFilter()-&gt;internalDoFilter()-&gt;Servlet#service()10 -&gt;HttpServlet#service()-&gt;doGet()/doPost() 6. Web部署方式​ Tomcat有三种部署方式，由HostConfig#START_EVENT事件来完成。 Context描述文件部署 Web目录部署 War包部署 7. JSP引擎​ 对应基于JSP的Web应用，可以直接在JSP中写Java代码，添加第三方标签库，以及EL表达式。但是无论经过任何形式的处理，最终输出到用户客户端依然是HTML静态页面（包括JS、CSS等），并不包含任何Java相关的语法。 ​ Jasper模块是Tomcat的JSP核心引擎，Tomcat使用Jasper对JSP语法进行解析，生成Servlet并编译成Class字节码，用户在访问JSP时，会访问Servlet，最终将响应的结果直接返回给客户端。在运行时，Jasper会检测JSP文件是否修改，如果修改则重新编译JSP文件。 ​ 注意：目前新项目中JSP应用较少，没有深入进行分析，后续如果需要可以进一步了解。","categories":[],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"单例模式","slug":"单例模式","date":"2019-11-18T11:57:46.000Z","updated":"2019-12-06T02:56:04.828Z","comments":true,"path":"2019/11/18/单例模式/","link":"","permalink":"http://yoursite.com/2019/11/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"单例模式是设计模式中使用最多的模式之一，它是一种对象的创建模式，用于产生一个对象的实例，确保系统中一个类只有一个实例。在Java语言中，单例模式有以下好处： 对于频繁使用的对象，单例省略了创建对象的时间，对于重量级对象而言，极大减少了系统开销。 由于new的次数减少，因此减少了系统对内存的使用频次，减轻了GC压力，缩短了GC停顿时间。 因此对于系统的关键组件和频繁使用的对象，可以设计为单例模式，减少系统的开销，提高系统性能。","text":"单例模式是设计模式中使用最多的模式之一，它是一种对象的创建模式，用于产生一个对象的实例，确保系统中一个类只有一个实例。在Java语言中，单例模式有以下好处： 对于频繁使用的对象，单例省略了创建对象的时间，对于重量级对象而言，极大减少了系统开销。 由于new的次数减少，因此减少了系统对内存的使用频次，减轻了GC压力，缩短了GC停顿时间。 因此对于系统的关键组件和频繁使用的对象，可以设计为单例模式，减少系统的开销，提高系统性能。 ​ 单例模式的参与者很少，只有单例类和使用者，关系表如下： 角色 作用 单例类 提供单例的工厂，返回单例 使用者 获取并使用单例 ​ 类图如下： 实现方式一（饿汉）：单例模式的核心在于通过一个接口返回唯一实例化对象，简单实现如下： 1&#x2F;**2 * 单例模式--饿汉（无法做到延时加载）3 *&#x2F;4public class HungrySingleton &#123;56 private static HungrySingleton instance &#x3D; new HungrySingleton();78 &#x2F;**9 * 私有构造方法10 *&#x2F;11 private HungrySingleton()&#123;12 System.out.println(&quot;创建了对象&quot;);13 &#125;1415 &#x2F;**16 * 对外暴露的获取唯一实例的接口17 * @return18 *&#x2F;19 public static HungrySingleton getInstance()&#123;20 return instance;21 &#125;2223 &#x2F;**24 * 序列化，反序列化保证单例25 * @return26 *&#x2F;27 private Object readResolve()&#123;28 return instance;29 &#125;30&#125; ​ 原理：单例类必须私有化构造方法，保证不会在系统其他地方调用，其次instance成员变量和getInstance()方法必须是static修饰的。 ​ 注意：单例模式的这种实现方式非常简单，十分可靠，唯一不足是无法做到延时加载。假设单例的创建过程十分缓慢，由于instance的成员变量是由static修饰的，在JVM加载单例类的时候，单例对象就会存在，如果单例类还在系统中扮演别的角色，那么系统中任何使用单例类的地方都会初始化这个单例对象，而不管是否被用到。 实现方式二（懒汉）：为了解决上述问题，并提高系统在相关函数调用的反应速度，就需要加入延时加载机制，懒汉模式。 1&#x2F;**2 * 单例模式--懒汉（效率低，延时加载）3 *&#x2F;4public class LazySingleton &#123;56 private static LazySingleton instance &#x3D; null;78 private LazySingleton() &#123;9 System.out.println(&quot;LazySingleton is create&quot;);10 &#125;1112 public static synchronized LazySingleton getInstance() &#123;13 if (instance &#x3D;&#x3D; null) &#123;14 return new LazySingleton();15 &#125;16 return instance;17 &#125;18&#125; ​ 原理：首先，静态成员变量instance赋值为null，确保系统启动时没有额外负载，其次在getInstance()方法中判断当前单例instance对象是否存在，存在则返回，不存在创建单例对象。 ​ 注意：getInstance()必须是线程同步的，否则在多线程条件下，当线程1新建单例完成赋值前，线程2可能判断instance为null，线程2也创建了单例对象，导致多个实例被创建，因此同步关键字是必须的。使用上述单例模式的实现方式，虽然实现了延时加载，但是和第一种实现（饿汉）相比，引入了同步关键字，因此在多线程场景下，加载速度远远大于第一种实现方式，影响系统性能。 实现方式三（内部类）：继续改进，创建内部类： 1&#x2F;**2 * 使用内部类来维护单例的实例，当StaticSingleton被加载时候，内部类并没有被初始化3 * （instance并没有被初始化），调用getInstance()才会被初始化。4 *&#x2F;5public class StaticSingleton &#123;67 private StaticSingleton()&#123;8 System.out.println(&quot;StaticSingleton is create&quot;);9 &#125;1011 &#x2F;**12 * 内部类，创建单例对象13 *&#x2F;14 private static class StaticSingleHolder&#123;15 private static StaticSingleton instance &#x3D; new StaticSingleton();16 &#125;1718 public static StaticSingleton getInstance()&#123;19 return StaticSingleHolder.instance;20 &#125;21&#125; ​ 原理：在这个实现中，使用内部类来维护单例实例，当StaticSingleton被加载的时候，内部类没有被初始化，可以确保StaticSingleton加载到JVM中，不会初始化单例类，当调用getInstance()时才会加载StaticSingleHolder，初始化instance对象，同时由于实例的建立是在类加载时完成的，对线程友好，getInstance()不需要使用同步关键字。 ​ 注意：使用内部类实现的单例，既可以实现延时加载也避免使用同步关键字，是比较完善的实现。但是如果通过反射机制强行调用私有构造方法，就会生成多个单例。同时序列化和反序列化可能破坏单例(饿汉代码readResolve()方法)，场景不多见，如果存在，多加注意。 参考：《Java性能程序优化 让你的Java程序更快、更稳定 》 葛一鸣","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Integer面试题","slug":"Integer相关","date":"2019-11-18T10:43:46.000Z","updated":"2019-12-06T02:55:18.571Z","comments":true,"path":"2019/11/18/Integer相关/","link":"","permalink":"http://yoursite.com/2019/11/18/Integer%E7%9B%B8%E5%85%B3/","excerpt":"Integer是Java常用类，关于它的面试题层出不穷，在这里总结一下。","text":"Integer是Java常用类，关于它的面试题层出不穷，在这里总结一下。 1. Integer和int的区别和联系？ int是基本数据类型，缺省值为0，占内存4个字节，32bit。 Integer是引用类型，缺省值为null。 Integer和int之间相互转换存在自动拆装箱的过程。 1public static void main(String[] args) &#123;2 Integer a &#x3D; 200;3 Integer b &#x3D; 200;4 System.out.println(a &#x3D;&#x3D; b);5 System.out.println(a.equals(b));6&#125;7上述程序默认执行的结果:8false9true 解析 Integer默认的数字缓存区间为-128~127[a]，当数字在这个区间的时候，Integer a = 200;直接从IntegerCache中读取数据，不会创建新的对象（类似于字符串常量池），如果超出这个区间[a]就会构造新的Integer对象。”==”是引用比较，”equals”是对象的值比较（Integer重写了equals方法），a,b是不同的对象，==比较为false,他们的值相同都为200，equals为true。 特例：上述执行程序可能会有相反的结果，System.out.println(a == b)也可能为true。 1解析：2可以通过修改JVM启动参数修改IntegerCache上限（-XX:AutoBoxCacheMax&#x3D;250），Java进程启动时，会加载rt.jar这个核心包，rt.jat里面的Integer自然也被加载到JVM中，Integer中有个IntegerCache缓存，描述如下： 3 IntegerCache有一个静态代码块，JVM在加载这个类的时候会优先加载静态代码块。当JVM进程启动完毕后-128~127之间的数字就会被缓存起来，调用valueOf方法的时候，如果是在这个区间的数字直接从缓存中取，超过这个范围就只能构造新的Integer对象。 注意 使用Oracle/Sun JDK 6,在server模式下，使用-XX:AutoBoxCacheMax=NNN参数即可将Integer的自动缓存区间设置为[-128,NNN]，下边界固定为-128，不可配置。 在设置了-XX:+AggressiveOpts启动参数后，AutoBoxCacheMax的默认值会被修改为20000并且生效。 这篇文章主要是记录第二个面试，顺便回忆一下Integer和int的区别。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]}